<!DOCTYPE html>
<html>
  <head>
    <title>Post-introduction to React</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="trabe-slide-pack.css">
  </head>
  <body>

<textarea data-slide-pack>

-- trabe

# Post-introduction to React

--

# Our affaire with React, 2 years later

--

David Barral
david@trabe.io
@davidbarral

Cecilia García
ceci@trabe.io
@cecig2202


LOGO de trabe
https://trabe.io
@trabe

-- trabe-green

# React intro recap

--


# UI Library

UI = f(state)

--

# Virtual DOM

![](assets/virtual-dom.png)

Virtual DOM diagram

LDING ISOMORPHIC WEB APPLICATIONS
USING REACT AND NODE
Created by Donald Whyte
http://slidedeck.io/DonaldWhyte/isomorphic-react-workshop

-- code

# JSX

```javascript
import React from "react";
import { render } from "react-dom";

const HelloWorld = () =>
  <p>Hello world!</p>;

render(
  <HelloWorld/>,
  document.getElementById("app")
);
```

-- code

# JSX

```javascript
import React from "react";
import { render } from "react-dom";

const HelloWorld = () =>
  React.DOM.p(null, "Hello world!");

render(
  React.createElement(HelloWorld),
  document.getElementById("app")
);
```

-- code

# Stateless components

```javascript
const Layout = ({ title, children }) => (
  <div>
    <h1>{title}</h1>
    {children}
  </div>
);


<Layout title="MyApp">
  <p>Ola ke ase</p>
</Layout>
```

-- code

# Stateful components

```javascript
class Counter extends Component {
  state = {
    counter: 0,
  }

  handleClick = () => {
    this.setState({
      counter: this.state.counter + 1,
    });
  }

  render() {
    return <p onClick={this.handleClick}>{this.state.counter} clicks</p>;
  }
}

<Layout title="MyApp">
  <Counter />
</Layout>
```

--

# Lifecycle

## Mounting

* defaultProps / initialState
* componentWillMount
* render
* componentDidMount

## Updating state
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate

## Updating props
componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate

## Unmounting
componentWillUnmount


-- code

# Lifecycle

```javascript
const fetchData =
  new Promise(resolve => setTimeout(resolve, 1000));

class Data extends Component {
  state ={
    loading: true,
  }

  componentDidMount() {
    fetchData().then(() => {
      this.setState({ loading: false });
    });
  }

  render() {
    return this.state.loading
      ? <p>Loading...</p>
      : <p>Loaded</p>;
  }
}
```

--

## OK, so... now what?

 ![](assets/lost-kid.gif)

 <!-- Contexto. Trabe usa React. Y lo usa en proyectos de verdad y se come los marrones que toquen.-->

-- problem

# We'll talk about real problems

--

# And see how to solve them with React

-- gotchas

# Be aware of the gotchas

## Some of this stuff must be handled with care

--

## From "easy peasy"
 to
## "total mind fuck!"

![](assets/mind-blown.gif)

--

# Example code

![A panda coded this](assets/panda.gif)

[trabe-teaching/post-intro-react-examples](https://github.com/trabe-teaching/post-intro-react-examples)

--

# ES2017

--

LOGO de storybook

Using storybook

Screenshot para explicar la barra lateral

(poner en un solo nivel)


-- problem

# Fine control the render cycle

-- code

# Optimize render

```javascript
const List = ({ itemData }) => (
  <ul>
    { itemData.map(data => <Item data={data} /> }
  </ul>
);

class Item extends Component {

  shouldComponentUpdate(nextProps, _nextState) {
    return nextProps !== this.props;
  }

  render() {
    return <li>{this.props.data}</li>;
  }
}

```


-- code

# Rerender stateful components on props change

```
class Counter extends Component {
  state = {
    counter: this.props.initial,
  }

  handleClick = () => { /* state.counter += 1 */ }

  componentWillReceiveProps(nextProps) {
    if (nextProps.initial !== this.props.initial) {
      this.setState({
        counter: nextProps.initial,
      });
    }
  }

  render() { /* ... */ }
}
```

-- gotchas

* Check for relevant properties
* Identity check vs deep equality
* Inmutability FTW

-- code

# Use the updated state

```javascript
class Counter extends Component {

  // handleClick = () => {
  //   this.setState({
  //     counter: this.state.counter + 1,
  //   });
  // }

  handleClick = () => {
    this.setState((prevState, props) => ({
      counter: prevState.counter + 1,
    }));
  }

  render() { /* ... */ }
}
```

-- code

# Use the updated state

```javascript
class Counter extends Component {

  // handleClick = () => {
  //   this.setState({
  //     counter: this.state.counter + 1,
  //   }),
  //   () => {
  //     console.log("New counter", this.counter);
  //   });

  handleClick = () => {
    this.setState((prevState, props) => ({
      counter: prevState.counter + 1,
    })),
    () => {
      console.log("New counter", this.state.counter);
    });
  }

  render() { /* ... */ }
}
```

-- code

# Use the updated state

```javascript
class Counter extends Component {

  handleClick = () => {
    this.setState((prevState, props) => ({
      counter: prevState.counter + 1,
    }));
  }

  componentDidUpdate(prevPros, prevState) {
    console.log("New counter", this.state.counter);
  }

  render() { /* ... */ }
}
```

-- gotchas

# setState

* componentDidUpdate handles both props and state change


-- full-image

# It's gonna be ok

![](assets/gonna-be-ok.gif)


-- problem

# Forms

-- code

# Controlled components

```javascript
class ControlledForm extends Component {
  state = { value: 5 };

  handleChange = event =>
   this.setState({ value: event.target.value });

  handleSubmit = event => {
    event.preventDefault();
    alert(this.state.value);
  }

  render() {
    return (
      <form>
        <input type="text" value={this.state.value}
               onChange={this.handleChange} />
        <button onClick={this.handleSubmit}>Submit!</button>
      </form>
    );
  }
}
```

-- code

# Uncontrolled components & refs API

```javascript
const UncontrolledForm = () => {
  let input;

  const handleSubmit = event => {
    event.preventDefault();
    alert(input.value);
  }

  return (
    <form>
      <input ref={i => input = i} type="text" defaultValue="5" />
      <button onClick={handleSubmit}>Submit!</button>
    </form>
  );
}
```

--

# When to use refs

* Forms for performance reasons
* DOM manipulation, e.g. animations
* Non-React stuff integrations (more on that, later)
* Access custom componentes API

-- gotchas

* Not the React way (imperative mindset vs declarative)
* Ref to react node vs DOM node
* Wrapping: ref delegation

-- code

# Broken ref

```javascript
class A extends Component => {
  apiMethod() { /* ... */ }
}

const B = () => <A />;

let a;
<B ref={r => a = r} />;
a.apiMethod(); // broken ref
```

-- code
# Ref delegation

```javascript
class A extends Component => {
  apiMethod() { /* ... */ }
}

const B = () => <A ref={this.aRef} />;

let a;
<B aRef={r => b = r} />;
a.apiMethod() // delegates to A.apiMethod
```


-- code
# Ref delegation

```javascript
class A extends Component => {
  apiMethod() { /* ... */ }
}

class B extends Component {
  apiMethod() {
    this.a.apiMethod();
  }

  render() {
    return <A ref={r => this.a = r } />
  }
}

let b;
<B ref={r => b = r} />;
b.apiMethod() // delegates to A.apiMethod
```

-- full-image

# It's really gonna be ok

![](assets/really-gonna-be-ok.gif)


-- problem

# How do I pass props to deep nested components?

-- code

# Flowing props

```javascript
const T = ({ locale, key }) => `${key}.${locale}`;

const Content = ({ locale }) =>
  <h1><T locale={locale} key="app.title"/></h1>;

const App = ({ locale }) => <Content locale={locale} />;

<App locale="es" />
```

-- code

# Context API

```javascript
const T = ({ key }, { locale }) => `${key}.${locale}`;
T.contextTypes = { locale: PropTypes.string }

const Content = () => <h1><T key="app.title"/></h1>;

class App extends Component {
  static childContextTypes = {
    locale: PropTypes.string,
  };

  getChildContext() {
    return { locale: this.props.locale };
  }

  render() {
    return <Content />;
  }
);

<App locale="es" />
```


-- gotchas

* Experimental API
* Keep it minimu. Extract as a reusable concern to minimize deprecation problems


-- problem

# Extract common concerns

--

# HOCs

## High Order Component
## f(Component) => Component'

-- code

# HOC recipe

```javascript
const hoc = configuration => WrappedComponent =>
  (props) => {
    const enhacedProps = {
      ...process(configuration),
      ...props,
    };

    return (
      <WrappedComponentComponent {...enhacedProps} />
    );
  };

const EnhacedComponent = hoc(config)(MyComponent);

<EnhacedComponent prop1="1" prop2="2" />
```

-- code

# HOC recipe

```javascript
const hoc = configuration => WrappedComponent =>
  const Wrapper extends Component {
    componentWillReceiveProps() {
      // ...
    }

    render() {
      <Component {...this.props} {...additionalProps} />;
    }
  };

  return Wrapper;
};

const EnhacedComponent = hoc(config)(MyComponent);

<EnhacedComponent prop1="1" prop2="2" />
```

-- code
# Locale HOC

```javascript
const withLocale = WrappedComponent => {
  const Wrapper = (props, { locale }) =>
    <WrappedComponent locale={locale} {...props} />;

  Wrapper.contextTypes = { locale: PropTypes.string }
  Wrapper.displayName =
   `withLocale(${WrappedComponent.displayName})`;

  return Wrapper;
};


let T = ({ key }, { locale }) => `${key}.${locale}`;
T = withLocale(T);

```

--

# Recompose

Recompose Logo

--

# Recompose

Lista de método

* compose
* withState
* lifecycle
* withProps
* mapProps
* branch
* withContext
* wrapDisplayName
* pure
* shouldUpdate
* onlyUpdateForKeys
* ...

-- code

# Locale HOC with recompose

```
const withLocale = compose(
  wrapDisplayName("withLocale"),
  getContext({ locale: PropTypes.string }),
);

let T = ({ key }, { locale }) => `${key}.${locale}`;
T = withLocale(T);

```

-- code

# Component refactoring

```
Counter example qith withState y witHandlers
```









--

![](http://pbs.twimg.com/media/CV-axvvXAAA1TCT.jpg:large)




































-- problem

# How do I detect context changes


--

You can't...

--

Suscripción al contexo. ej.
Cambio de locale. Oh wau



--

import { connect } from "react-redux";

Connect. The most famous HOC around


--

# Challenge

Code your own Redux

--

Store - State (subscription mechanism)
Provider - Context Provider
connect - HOC

ejemplo: poor man redux


-- problem

# Inject dependecneies

--

API Children. Inyección de deps.

Pasar info de padres a hijos sin usar props, porque no conoces tu hijo.

algo así!

<WithTheme theme="">
{(fgColor, bgColor) => <MyComponent style={color: fgColor, bac

  })
           kground: bgColor} />

</WithTheme>

vs sacar el tema para fuera

--

Contraponer con API de children como alternativa (form inyecta su fiunciójn de reset).
--

Children.clone

children function

-- problem

# Como hago "layout" components

--

* Children:
  * Manipulación de children: estructurar componentes. Magia negra


  <Popup>
    <Header></Header>
    <Content></Content>
    <button>dasdas</button>
    </button
  </Popup>

  </MyShit>
--

  Enfrentearlo a hijos en props

  <Popup header={header} content={content} />
--


-- problem

# Integrate non react stuff

-- code

# Integrate DOM manipulation

```
Refs API again
componentDidMount, componentWillUnmount, ShouldComponentUpdate

```

## jQuery, D3...

--







-- problem

# How do I really Manage my application state

--

Redux! (o mobx)


-- problem

# Testing my components

--

Enzyme + Jests (snapshot testing)

--


# Parting notes

--

# Use, but not abuse

Muchas de estas cosas no se necesitan si se usa un estado global ala Redux
* Ejemplo el contexto puede ser un foco de problemas -> estado global. ESTADO => UI
* Manipular children. Rompe la base.

--

# Update your react

## React 15.5 (deprecation)
### Deprecation madness
## React 16 (Fiber)
### By bye wrappers.

--

Questions?

--

See ya!










</textarea>
    <!-- SlidePack markdown compilation & UI goodies -->
    <script src="slide-pack.js"></script>
  </body>
</html>
